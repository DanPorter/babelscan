

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>babelscan.fitting &mdash; BabelScan 0.3.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> BabelScan
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code/Code.html">Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plotting/Plotting.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fitting/Fitting.html">Fitting</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BabelScan</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>babelscan.fitting</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for babelscan.fitting</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Fitting functions using lmfit</span>

<span class="sd">See: https://lmfit.github.io/lmfit-py/builtin_models.html</span>

<span class="sd">Use of peakfit:</span>
<span class="sd">from fitting import peakfit</span>
<span class="sd">fit = peakfit(xdata, ydata)  # returns lmfit object</span>
<span class="sd">print(fit)</span>
<span class="sd">fit.plot()</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">lmfit.models</span> <span class="kn">import</span> <span class="n">GaussianModel</span><span class="p">,</span> <span class="n">LorentzianModel</span><span class="p">,</span> <span class="n">VoigtModel</span><span class="p">,</span> <span class="n">PseudoVoigtModel</span><span class="p">,</span> <span class="n">LinearModel</span><span class="p">,</span> <span class="n">ExponentialModel</span>

<span class="c1"># https://lmfit.github.io/lmfit-py/builtin_models.html#peak-like-models</span>
<span class="n">MODELS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span> <span class="n">GaussianModel</span><span class="p">,</span>
    <span class="s1">&#39;lorentz&#39;</span><span class="p">:</span> <span class="n">LorentzianModel</span><span class="p">,</span>
    <span class="s1">&#39;voight&#39;</span><span class="p">:</span> <span class="n">VoigtModel</span><span class="p">,</span>
    <span class="s1">&#39;pvoight&#39;</span><span class="p">:</span> <span class="n">PseudoVoigtModel</span><span class="p">,</span>
    <span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="n">LinearModel</span><span class="p">,</span>
    <span class="s1">&#39;exponential&#39;</span><span class="p">:</span> <span class="n">ExponentialModel</span>
<span class="p">}</span>

<span class="n">PEAK_MODELS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;gaussian&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;gaussian&#39;</span><span class="p">,</span> <span class="s1">&#39;gauss&#39;</span><span class="p">],</span>
    <span class="s1">&#39;voight&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;voight&#39;</span><span class="p">,</span> <span class="s1">&#39;voight model&#39;</span><span class="p">],</span>
    <span class="s1">&#39;pvoight&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;pseudovoight&#39;</span><span class="p">,</span> <span class="s1">&#39;pvoight&#39;</span><span class="p">],</span>
    <span class="s1">&#39;lorentz&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;lorentz&#39;</span><span class="p">,</span> <span class="s1">&#39;lorentzian&#39;</span><span class="p">,</span> <span class="s1">&#39;lor&#39;</span><span class="p">],</span>
<span class="p">}</span>

<span class="n">BACKGROUND_MODELS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;linear&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;straight&#39;</span><span class="p">],</span>
    <span class="s1">&#39;exponential&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;exponential&#39;</span><span class="p">,</span> <span class="s1">&#39;curve&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># https://lmfit.github.io/lmfit-py/fitting.html#fit-methods-table</span>
<span class="n">METHODS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;leastsq&#39;</span><span class="p">:</span> <span class="s1">&#39;Levenberg-Marquardt&#39;</span><span class="p">,</span>
    <span class="s1">&#39;nelder&#39;</span><span class="p">:</span> <span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span>
    <span class="s1">&#39;lbfgsb&#39;</span><span class="p">:</span> <span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">,</span>
    <span class="s1">&#39;powell&#39;</span><span class="p">:</span> <span class="s1">&#39;Powell&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cg&#39;</span><span class="p">:</span> <span class="s1">&#39;Conjugate Gradient&#39;</span><span class="p">,</span>
    <span class="s1">&#39;newton&#39;</span><span class="p">:</span> <span class="s1">&#39;Newton-CG&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cobyla&#39;</span><span class="p">:</span> <span class="s1">&#39;COBYLA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;bfgsb&#39;</span><span class="p">:</span> <span class="s1">&#39;BFGS&#39;</span><span class="p">,</span>
    <span class="s1">&#39;tnc&#39;</span><span class="p">:</span> <span class="s1">&#39;Truncated Newton&#39;</span><span class="p">,</span>
    <span class="s1">&#39;trust-ncg&#39;</span><span class="p">:</span> <span class="s1">&#39;Newton CG trust-region&#39;</span><span class="p">,</span>
    <span class="s1">&#39;trust-exact&#39;</span><span class="p">:</span> <span class="s1">&#39;Exact trust-region&#39;</span><span class="p">,</span>
    <span class="s1">&#39;trust-krylov&#39;</span><span class="p">:</span> <span class="s1">&#39;Newton GLTR trust-region&#39;</span><span class="p">,</span>
    <span class="s1">&#39;trust-constr&#39;</span><span class="p">:</span> <span class="s1">&#39;Constrained trust-region&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dogleg&#39;</span><span class="p">:</span> <span class="s1">&#39;Dogleg&#39;</span><span class="p">,</span>
    <span class="s1">&#39;slsqp&#39;</span><span class="p">:</span> <span class="s1">&#39;Sequential Linear Squares Programming&#39;</span><span class="p">,</span>
    <span class="s1">&#39;differential_evolution&#39;</span><span class="p">:</span> <span class="s1">&#39;Differential Evolution&#39;</span><span class="p">,</span>
    <span class="s1">&#39;brute&#39;</span><span class="p">:</span> <span class="s1">&#39;Brute force method&#39;</span><span class="p">,</span>
    <span class="s1">&#39;basinhopping&#39;</span><span class="p">:</span> <span class="s1">&#39;Basinhopping&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ampgo&#39;</span><span class="p">:</span> <span class="s1">&#39;Adaptive Memory Programming for Global Optimization&#39;</span><span class="p">,</span>
    <span class="s1">&#39;shgo&#39;</span><span class="p">:</span> <span class="s1">&#39;Simplicial Homology Global Ooptimization&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dual_annealing&#39;</span><span class="p">:</span> <span class="s1">&#39;Dual Annealing&#39;</span><span class="p">,</span>
    <span class="s1">&#39;emcee&#39;</span><span class="p">:</span> <span class="s1">&#39;Maximum likelihood via Monte-Carlo Markov Chain&#39;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">error_func</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Default error function&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">peak_ratio</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerror</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the ratio signal / error for given dataset</span>
<span class="sd">    From Blessing, J. Appl. Cryst. (1997). 30, 421-426 Equ: (1) + (6)</span>
<span class="sd">      peak_ratio = (sum((y-bkg)/dy^2)/sum(1/dy^2)) / sqrt(i/sum(1/dy^2))</span>
<span class="sd">    :param y: array of y data</span>
<span class="sd">    :param yerror: array of errors on data, or None to calcualte np.sqrt(y+0.001)</span>
<span class="sd">    :return: float ratio signal / err</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">yerror</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">yerror</span> <span class="o">=</span> <span class="n">error_func</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">bkg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">wi</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">yerror</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wi</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">bkg</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wi</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">err</span>


<span class="k">def</span> <span class="nf">gen_weights</span><span class="p">(</span><span class="n">yerrors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate weights for fitting routines</span>
<span class="sd">    :param yerrors: array(n) or None</span>
<span class="sd">    :return: array(n) or None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">yerrors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yerrors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">):</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yerrors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yerrors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">yerrors</span><span class="p">[</span><span class="n">yerrors</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">yerrors</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">weights</span>


<span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cen</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fwhm</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">bkg</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define Gaussian distribution in 1 or 2 dimensions</span>
<span class="sd">    From http://fityk.nieto.pl/model.html</span>
<span class="sd">        x = [1xn] array of values, defines size of gaussian in dimension 1</span>
<span class="sd">        y = None* or [1xm] array of values, defines size of gaussian in dimension 2</span>
<span class="sd">        height = peak height</span>
<span class="sd">        cen = peak centre</span>
<span class="sd">        fwhm = peak full width at half-max</span>
<span class="sd">        bkg = background</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">cen</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">X</span> <span class="o">-</span> <span class="n">cen</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="n">cen</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">fwhm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">bkg</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">g</span>


<span class="k">def</span> <span class="nf">group_adjacent</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Average adjacent values in array, return grouped array and indexes to return groups to original array</span>
<span class="sd">    E.G.</span>
<span class="sd">     grp, idx = group_adjacent([1,2,3,10,12,31], close=3)</span>
<span class="sd">     grp -&gt; [2, 11, 31]</span>
<span class="sd">     idx -&gt; [[0,1,2], [3,4], [5]]</span>

<span class="sd">    :param values: array of values to be grouped</span>
<span class="sd">    :param close: float</span>
<span class="sd">    :return grouped_values: float array(n) of grouped values</span>
<span class="sd">    :return indexes: [n] list of lists, each item relates to an averaged group, with indexes from values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check distance between good peaks</span>
    <span class="n">dist_chk</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dist_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">gx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">gx</span><span class="p">]]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">gx</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">gx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">gx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">gx</span><span class="p">]</span> <span class="o">-</span> <span class="n">values</span><span class="p">[</span><span class="n">gx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">close</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">+=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">gx</span><span class="p">]]</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="p">[</span><span class="n">gx</span><span class="p">]</span>
            <span class="c1"># print(&#39;Close %2d %2d %2d  %s&#39; % (gx, indexes[gx], indexes[gx-1], dist))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist_chk</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
            <span class="n">dist_idx</span> <span class="o">+=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">gx</span><span class="p">]]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">gx</span><span class="p">]</span>
            <span class="c1"># print(&#39;Next %2d %2d %2d %s&#39; % (gx, indexes[gx], indexes[gx-1], dist_chk))</span>
    <span class="n">dist_chk</span> <span class="o">+=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">)]</span>
    <span class="n">dist_idx</span> <span class="o">+=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="c1"># print(&#39;Last %2d %2d %2d %s&#39; % (gx, indexes[gx], indexes[gx-1], dist_chk))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_chk</span><span class="p">),</span> <span class="n">dist_idx</span>


<span class="k">def</span> <span class="nf">local_maxima_1d</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find local maxima in 1d array</span>
<span class="sd">    Returns points with central point higher than neighboring points</span>
<span class="sd">    Copied from scipy.signal._peak_finding_utils</span>
<span class="sd">    https://github.com/scipy/scipy/blob/v1.7.1/scipy/signal/_peak_finding_utils.pyx</span>
<span class="sd">    :param y: list or array</span>
<span class="sd">    :return: array of peak indexes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Preallocate, there can&#39;t be more maxima than half the size of `y`</span>
    <span class="n">midpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Pointer to the end of valid area in allocated arrays</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Pointer to current sample, first one can&#39;t be maxima</span>
    <span class="n">i_max</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Last sample can&#39;t be maxima</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_max</span><span class="p">:</span>
        <span class="c1"># Test if previous sample is smaller</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">i_ahead</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Index to look ahead of current sample</span>

            <span class="c1"># Find next sample that is unequal to x[i]</span>
            <span class="k">while</span> <span class="n">i_ahead</span> <span class="o">&lt;</span> <span class="n">i_max</span> <span class="ow">and</span> <span class="n">y</span><span class="p">[</span><span class="n">i_ahead</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">i_ahead</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Maxima is found if next unequal sample is smaller than x[i]</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i_ahead</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">left_edge</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">right_edge</span> <span class="o">=</span> <span class="n">i_ahead</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">midpoints</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">left_edge</span> <span class="o">+</span> <span class="n">right_edge</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Skip samples that can&#39;t be maximum</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i_ahead</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">midpoints</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">find_local_maxima</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerror</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find local maxima in 1d arrays, returns index of local maximums, plus</span>
<span class="sd">    estimation of the peak power for each maxima and a classification of whether the maxima is greater than</span>
<span class="sd">    the standard deviation of the error</span>
<span class="sd">    E.G.</span>
<span class="sd">        index, power, isgood = find_local_maxima(ydata)</span>
<span class="sd">        maxima = ydata[index[isgood]]</span>
<span class="sd">        maxima_power = power[isgood]</span>
<span class="sd">    Peak Power:</span>
<span class="sd">      peak power for each maxima is calculated using the peak_ratio algorithm for each maxima and adjacent points</span>
<span class="sd">    Good Peaks:</span>
<span class="sd">      Maxima are returned Good if:  power &gt; (max(y) - min(y)) / std(yerror)</span>
<span class="sd">    :param y: array(n) of data</span>
<span class="sd">    :param yerror: array(n) of errors on data, or None to use default error function (sqrt(abs(y)+1))</span>
<span class="sd">    :return index: array(m&lt;n) of indexes in y of maxima</span>
<span class="sd">    :return power: array(m) of estimated peak power for each maxima</span>
<span class="sd">    :return isgood: bool array(m) where True elements have power &gt; power of the array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">yerror</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yerror</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">):</span>
        <span class="n">yerror</span> <span class="o">=</span> <span class="n">error_func</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">yerror</span><span class="p">[</span><span class="n">yerror</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">bkg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">wi</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">yerror</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">local_maxima_1d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="c1"># average nearest 3 points to peak</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wi</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bkg</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wi</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">index</span><span class="p">])</span>
    <span class="c1"># Determine if peak is good</span>
    <span class="n">isgood</span> <span class="o">=</span> <span class="n">power</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">yerror</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">isgood</span>


<span class="k">def</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerror</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find peak shaps in linear-spaced 1d arrays with poisson like numerical values</span>
<span class="sd">    E.G.</span>
<span class="sd">      index, power = find_peaks(ydata, yerror, min_peak_power=None, peak_distance_idx=10)</span>
<span class="sd">      peak_centres = xdata[index]  # ordered by peak strength</span>
<span class="sd">    :param y: array(n) of data</span>
<span class="sd">    :param yerror: array(n) of errors on data, or None to use default error function (sqrt(abs(y)+1))</span>
<span class="sd">    :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">    :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">    :return index: array(m) of indexes in y of peaks that satisfy conditions</span>
<span class="sd">    :return power: array(m) of estimated power of each peak</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get all peak positions</span>
    <span class="n">midpoints</span><span class="p">,</span> <span class="n">peak_signals</span><span class="p">,</span> <span class="n">chk</span> <span class="o">=</span> <span class="n">find_local_maxima</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerror</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">min_peak_power</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">good_peaks</span> <span class="o">=</span> <span class="n">chk</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">good_peaks</span> <span class="o">=</span> <span class="n">peak_signals</span> <span class="o">&gt;=</span> <span class="n">min_peak_power</span>

    <span class="c1"># select indexes of good peaks</span>
    <span class="n">peaks_idx</span> <span class="o">=</span> <span class="n">midpoints</span><span class="p">[</span><span class="n">good_peaks</span><span class="p">]</span>
    <span class="n">peak_power</span> <span class="o">=</span> <span class="n">peak_signals</span><span class="p">[</span><span class="n">good_peaks</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">peaks_idx</span><span class="p">,</span> <span class="n">peak_power</span>

    <span class="c1"># Average peaks close to each other</span>
    <span class="n">group_idx</span><span class="p">,</span> <span class="n">group_signal_idx</span> <span class="o">=</span> <span class="n">group_adjacent</span><span class="p">(</span><span class="n">peaks_idx</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="p">)</span>
    <span class="n">peaks_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">group_idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">peak_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">peak_power</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">group_signal_idx</span><span class="p">])</span>

    <span class="c1"># sort peak order by strength</span>
    <span class="n">power_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">peak_power</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">peaks_idx</span><span class="p">[</span><span class="n">power_sort</span><span class="p">],</span> <span class="n">peak_power</span><span class="p">[</span><span class="n">power_sort</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">peak_results</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate totals dict</span>
<span class="sd">    :param res: lmfit_result</span>
<span class="sd">    :return: {totals: (value, error)}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">peak_prefx</span> <span class="o">=</span> <span class="p">[</span><span class="n">mod</span><span class="o">.</span><span class="n">prefix</span> <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">components</span> <span class="k">if</span> <span class="s1">&#39;bkg&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mod</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span>
    <span class="n">npeaks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_prefx</span><span class="p">)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_prefx</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_prefx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">comps</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">eval_components</span><span class="p">()</span>
    <span class="n">fit_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;lmfit&#39;</span><span class="p">:</span> <span class="n">res</span><span class="p">,</span>
        <span class="s1">&#39;npeaks&#39;</span><span class="p">:</span> <span class="n">npeaks</span><span class="p">,</span>
        <span class="s1">&#39;chisqr&#39;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">chisqr</span><span class="p">,</span>
        <span class="s1">&#39;xdata&#39;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">userkws</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span>
        <span class="s1">&#39;ydata&#39;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="s1">&#39;weights&#39;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span>
        <span class="s1">&#39;yerror&#39;</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">res</span><span class="o">.</span><span class="n">weights</span> <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">res</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="s1">&#39;yfit&#39;</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">best_fit</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">comp_prefx</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">comps</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">fit_dict</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">fit&#39;</span> <span class="o">%</span> <span class="n">comp_prefx</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp</span>
    <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">ename</span> <span class="o">=</span> <span class="s1">&#39;stderr_&#39;</span> <span class="o">+</span> <span class="n">pname</span>
        <span class="n">fit_dict</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
        <span class="n">fit_dict</span><span class="p">[</span><span class="n">ename</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">stderr</span>
    <span class="n">totals</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;amplitude&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">amplitude&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]),</span>
        <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">center&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]),</span>
        <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">sigma&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]),</span>
        <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">height&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]),</span>
        <span class="s1">&#39;fwhm&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">fwhm&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]),</span>
        <span class="s1">&#39;background&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">comps</span><span class="p">[</span><span class="s1">&#39;bkg_&#39;</span><span class="p">]),</span>
        <span class="s1">&#39;stderr_amplitude&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">amplitude&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">])),</span>
        <span class="s1">&#39;stderr_center&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">center&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]))</span> <span class="o">*</span> <span class="n">nn</span><span class="p">,</span>
        <span class="s1">&#39;stderr_sigma&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">sigma&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]))</span> <span class="o">*</span> <span class="n">nn</span><span class="p">,</span>
        <span class="s1">&#39;stderr_height&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">height&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]))</span> <span class="o">*</span> <span class="n">nn</span><span class="p">,</span>
        <span class="s1">&#39;stderr_fwhm&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">fwhm&#39;</span> <span class="o">%</span> <span class="n">pfx</span><span class="p">]</span><span class="o">.</span><span class="n">stderr</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">pfx</span> <span class="ow">in</span> <span class="n">peak_prefx</span><span class="p">]))</span> <span class="o">*</span> <span class="n">nn</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">fit_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">totals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fit_dict</span>


<span class="k">def</span> <span class="nf">modelfit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span> <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit x,y data to a model from lmfit</span>
<span class="sd">    E.G.:</span>
<span class="sd">      res = peakfit(x, y, model=&#39;Gauss&#39;)</span>
<span class="sd">      print(res.fit_report())</span>
<span class="sd">      res.plot()</span>
<span class="sd">      val = res.params[&#39;amplitude&#39;].value</span>
<span class="sd">      err = res.params[&#39;amplitude&#39;].stderr</span>

<span class="sd">    Model:</span>
<span class="sd">     from lmfit import models</span>
<span class="sd">     model1 = model.GaussianModel()</span>
<span class="sd">     model2 = model.LinearModel()</span>
<span class="sd">     model = model1 + model2</span>
<span class="sd">     res = model.fit(y, x=x)</span>

<span class="sd">    Provide initial guess:</span>
<span class="sd">      res = modelfit(x, y, model=VoightModel(), initial_parameters={&#39;center&#39;:1.23})</span>

<span class="sd">    Fix parameter:</span>
<span class="sd">      res = modelfit(x, y, model=VoightModel(), fix_parameters={&#39;sigma&#39;: fwhm/2.3548200})</span>

<span class="sd">    :param xvals: array(n) position data</span>
<span class="sd">    :param yvals: array(n) intensity data</span>
<span class="sd">    :param yerrors: None or array(n) - error data to pass to fitting function as weights: 1/errors^2</span>
<span class="sd">    :param model: lmfit.Model</span>
<span class="sd">    :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">    :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">    :param method: str method name, from lmfit fitting methods</span>
<span class="sd">    :param print_result: if True, prints the fit results using fit.fit_report()</span>
<span class="sd">    :param plot_result: if True, plots the results using fit.plot()</span>
<span class="sd">    :return: lmfit.model.ModelResult &lt; fit results object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">gen_weights</span><span class="p">(</span><span class="n">yerrors</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fix_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fix_parameters</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">GaussianModel</span><span class="p">()</span> <span class="o">+</span> <span class="n">LinearModel</span><span class="p">()</span>

    <span class="n">pars</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>

    <span class="c1"># user input parameters</span>
    <span class="k">for</span> <span class="n">ipar</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">initial_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ipar</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">ipar</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ival</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ipar</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">fix_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ipar</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">ipar</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ival</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">xvals</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_result</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">peakfit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Voight&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span>
            <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span> <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit x,y data to a peak model using lmfit</span>
<span class="sd">    E.G.:</span>
<span class="sd">      res = peakfit(x, y, model=&#39;Gauss&#39;)</span>
<span class="sd">      print(res.fit_report())</span>
<span class="sd">      res.plot()</span>
<span class="sd">      val = res.params[&#39;amplitude&#39;].value</span>
<span class="sd">      err = res.params[&#39;amplitude&#39;].stderr</span>

<span class="sd">    Peak Models:</span>
<span class="sd">     Choice of peak model: &#39;Gaussian&#39;, &#39;Lorentzian&#39;, &#39;Voight&#39;,&#39; PseudoVoight&#39;</span>
<span class="sd">    Background Models:</span>
<span class="sd">     Choice of background model: &#39;slope&#39;, &#39;exponential&#39;</span>

<span class="sd">    Peak Parameters:</span>
<span class="sd">     &#39;amplitude&#39;, &#39;center&#39;, &#39;sigma&#39;, pvoight only: &#39;fraction&#39;</span>
<span class="sd">     output only: &#39;fwhm&#39;, &#39;height&#39;</span>
<span class="sd">    Background parameters:</span>
<span class="sd">     &#39;bkg_slope&#39;, &#39;bkg_intercept&#39;, or for exponential: &#39;bkg_amplitude&#39;, &#39;bkg_decay&#39;</span>

<span class="sd">    Provide initial guess:</span>
<span class="sd">      res = peakfit(x, y, model=&#39;Voight&#39;, initial_parameters={&#39;center&#39;:1.23})</span>

<span class="sd">    Fix parameter:</span>
<span class="sd">      res = peakfit(x, y, model=&#39;gauss&#39;, fix_parameters={&#39;sigma&#39;: fwhm/2.3548200})</span>

<span class="sd">    :param xvals: array(n) position data</span>
<span class="sd">    :param yvals: array(n) intensity data</span>
<span class="sd">    :param yerrors: None or array(n) - error data to pass to fitting function as weights: 1/errors^2</span>
<span class="sd">    :param model: str, specify the peak model: &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">    :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">    :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">    :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">    :param method: str method name, from lmfit fitting methods</span>
<span class="sd">    :param print_result: if True, prints the fit results using fit.fit_report()</span>
<span class="sd">    :param plot_result: if True, plots the results using fit.plot()</span>
<span class="sd">    :return: lmfit.model.ModelResult &lt; fit results object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">gen_weights</span><span class="p">(</span><span class="n">yerrors</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fix_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fix_parameters</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">peak_mod</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bkg_mod</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">PEAK_MODELS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">peak_mod</span> <span class="o">=</span> <span class="n">MODELS</span><span class="p">[</span><span class="n">model_name</span><span class="p">]()</span>
    <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">BACKGROUND_MODELS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">background</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">bkg_mod</span> <span class="o">=</span> <span class="n">MODELS</span><span class="p">[</span><span class="n">model_name</span><span class="p">](</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;bkg_&#39;</span><span class="p">)</span>

    <span class="n">pars</span> <span class="o">=</span> <span class="n">peak_mod</span><span class="o">.</span><span class="n">guess</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">xvals</span><span class="p">)</span>
    <span class="n">pars</span> <span class="o">+=</span> <span class="n">bkg_mod</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>
    <span class="c1"># pars += bkg_mod.make_params(intercept=np.min(yvals), slope=0)</span>
    <span class="c1"># pars[&#39;gamma&#39;].set(value=0.7, vary=True, expr=&#39;&#39;) # don&#39;t fix gamma</span>

    <span class="c1"># user input parameters</span>
    <span class="k">for</span> <span class="n">ipar</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">initial_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ipar</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">ipar</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ival</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ipar</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">fix_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ipar</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">ipar</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ival</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">peak_mod</span> <span class="o">+</span> <span class="n">bkg_mod</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">xvals</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_result</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="n">res</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">peak2dfit</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">image_data</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit Gaussian Peak in 2D</span>
<span class="sd">    *** requires lmfit &gt; 1.0.3 ***</span>
<span class="sd">        Not yet finished!</span>
<span class="sd">    :param xdata:</span>
<span class="sd">    :param ydata:</span>
<span class="sd">    :param image_data:</span>
<span class="sd">    :param initial_parameters:</span>
<span class="sd">    :param fix_parameters:</span>
<span class="sd">    :param print_result:</span>
<span class="sd">    :param plot_result:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">lmfit.models</span> <span class="kn">import</span> <span class="n">Gaussian2dModel</span>  <span class="c1"># lmfit V1.0.3+</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not yet finished...&#39;</span><span class="p">)</span>
    <span class="k">pass</span>


<span class="k">def</span> <span class="nf">generate_model</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">npeaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                   <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate lmfit profile models</span>
<span class="sd">    See: https://lmfit.github.io/lmfit-py/builtin_models.html#example-3-fitting-multiple-peaks-and-using-prefixes</span>
<span class="sd">    E.G.:</span>
<span class="sd">      mod, pars = generate_model(x, y, npeaks=1, model=&#39;Gauss&#39;, backgroud=&#39;slope&#39;)</span>

<span class="sd">    Peak Search:</span>
<span class="sd">     The number of peaks and initial peak centers will be estimated using the find_peaks function. If npeaks is given,</span>
<span class="sd">     the largest npeaks will be used initially. &#39;min_peak_power&#39; and &#39;peak_distance_idx&#39; can be input to tailor the</span>
<span class="sd">     peak search results.</span>
<span class="sd">     If the peak search returns &lt; npeaks, fitting parameters will initially choose npeaks equally distributed points</span>

<span class="sd">    Peak Models:</span>
<span class="sd">     Choice of peak model: &#39;Gaussian&#39;, &#39;Lorentzian&#39;, &#39;Voight&#39;,&#39; PseudoVoight&#39;</span>
<span class="sd">    Background Models:</span>
<span class="sd">     Choice of background model: &#39;slope&#39;, &#39;exponential&#39;</span>

<span class="sd">    :param xvals: array(n) position data</span>
<span class="sd">    :param yvals: array(n) intensity data</span>
<span class="sd">    :param yerrors: None or array(n) - error data to pass to fitting function as weights: 1/errors^2</span>
<span class="sd">    :param npeaks: None or int number of peaks to fit. None will guess the number of peaks</span>
<span class="sd">    :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">    :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">    :param model: str or lmfit.Model, specify the peak model &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">    :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">    :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">    :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">    :return: lmfit.model.ModelResult &lt; fit results object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Find peaks</span>
    <span class="n">peak_idx</span><span class="p">,</span> <span class="n">peak_pow</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="p">)</span>
    <span class="n">peak_centers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">_center&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="n">xvals</span><span class="p">[</span><span class="n">peak_idx</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">))}</span>
    <span class="k">if</span> <span class="n">npeaks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">npeaks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_centers</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fix_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fix_parameters</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">peak_mod</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bkg_mod</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">PEAK_MODELS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">peak_mod</span> <span class="o">=</span> <span class="n">MODELS</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">BACKGROUND_MODELS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">background</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">bkg_mod</span> <span class="o">=</span> <span class="n">MODELS</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>

    <span class="n">mod</span> <span class="o">=</span> <span class="n">bkg_mod</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;bkg_&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npeaks</span><span class="p">):</span>
        <span class="n">mod</span> <span class="o">+=</span> <span class="n">peak_mod</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">_&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

    <span class="n">pars</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>

    <span class="c1"># initial parameters</span>
    <span class="n">min_wid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xvals</span><span class="p">))</span>
    <span class="n">max_wid</span> <span class="o">=</span> <span class="n">xvals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">xvals</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="n">yvals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">yvals</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">*</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">min_wid</span><span class="p">)</span>
    <span class="n">percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">npeaks</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">npeaks</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">pars</span><span class="p">[</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">_amplitude&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">area</span><span class="o">/</span><span class="n">npeaks</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">pars</span><span class="p">[</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">_sigma&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">min_wid</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="n">min_wid</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">max_wid</span><span class="p">)</span>
        <span class="n">pars</span><span class="p">[</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">_center&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">percentile</span><span class="p">[</span><span class="n">n</span><span class="p">]),</span> <span class="nb">min</span><span class="o">=</span><span class="n">xvals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="nb">max</span><span class="o">=</span><span class="n">xvals</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="c1"># find_peak centers</span>
    <span class="k">for</span> <span class="n">ipar</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">peak_centers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ipar</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">ipar</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ival</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># user input parameters</span>
    <span class="k">for</span> <span class="n">ipar</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">initial_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ipar</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">ipar</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ival</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ipar</span><span class="p">,</span> <span class="n">ival</span> <span class="ow">in</span> <span class="n">fix_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ipar</span> <span class="ow">in</span> <span class="n">pars</span><span class="p">:</span>
            <span class="n">pars</span><span class="p">[</span><span class="n">ipar</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">ival</span><span class="p">,</span> <span class="n">vary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mod</span><span class="p">,</span> <span class="n">pars</span>


<span class="k">def</span> <span class="nf">generate_model_script</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">npeaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                          <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">include_babelscan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate script to create lmfit profile models</span>
<span class="sd">    E.G.:</span>
<span class="sd">      string = generate_mode_stringl(x, y, npeaks=1, model=&#39;Gauss&#39;, backgroud=&#39;slope&#39;)</span>

<span class="sd">    :param xvals: array(n) position data</span>
<span class="sd">    :param yvals: array(n) intensity data</span>
<span class="sd">    :param yerrors: None or array(n) - error data to pass to fitting function as weights: 1/errors^2</span>
<span class="sd">    :param npeaks: None or int number of peaks to fit. None will guess the number of peaks</span>
<span class="sd">    :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">    :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">    :param model: str or lmfit.Model, specify the peak model &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">    :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">    :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">    :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">    :param include_babelscan: if False, only include lmfit imports</span>
<span class="sd">    :return: str</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;xdata = np.array(</span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">+=</span> <span class="s2">&quot;ydata = np.array(</span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">yvals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">yerrors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yerrors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">+=</span> <span class="s1">&#39;yerrors = None</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">data</span> <span class="o">+=</span> <span class="s1">&#39;weights = None</span><span class="se">\n\n</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">+=</span> <span class="s2">&quot;yerrors = np.array(</span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">list</span><span class="p">(</span><span class="n">yerrors</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">+=</span> <span class="s2">&quot;yerrors[yerrors &lt; 1] = 1.0</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">data</span> <span class="o">+=</span> <span class="s2">&quot;weights = 1 / yerrors</span><span class="se">\n\n</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">initial_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">initial_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">fix_parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fix_parameters</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">params</span> <span class="o">=</span> <span class="s2">&quot;initial = </span><span class="si">%s</span><span class="se">\n</span><span class="s2">fixed = </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">initial_parameters</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_babelscan</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;import numpy as np</span><span class="se">\n</span><span class="s2">from babelscan import fitting</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">data</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">params</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;mod, pars = fitting.generate_model(xdata, ydata, yerrors,</span><span class="se">\n</span><span class="s2">&quot;</span> \
               <span class="s2">&quot;                                   npeaks=</span><span class="si">%s</span><span class="s2">, min_peak_power=</span><span class="si">%s</span><span class="s2">, peak_distance_idx=</span><span class="si">%s</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span> \
               <span class="s2">&quot;                                   model=&#39;</span><span class="si">%s</span><span class="s2">&#39;, background=&#39;</span><span class="si">%s</span><span class="s2">&#39;,</span><span class="se">\n</span><span class="s2">&quot;</span> \
               <span class="s2">&quot;                                   initial_parameters=initial, fix_parameters=fixed)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                   <span class="n">npeaks</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">background</span>
               <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Find peaks</span>
        <span class="n">peak_idx</span><span class="p">,</span> <span class="n">peak_pow</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="p">)</span>
        <span class="n">peak_centers</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;p</span><span class="si">%d</span><span class="s1">_center&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="n">xvals</span><span class="p">[</span><span class="n">peak_idx</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">peak_idx</span><span class="p">))}</span>
        <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">PEAK_MODELS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">peak_mod</span> <span class="o">=</span> <span class="n">MODELS</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">model_name</span><span class="p">,</span> <span class="n">names</span> <span class="ow">in</span> <span class="n">BACKGROUND_MODELS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">background</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">bkg_mod</span> <span class="o">=</span> <span class="n">MODELS</span><span class="p">[</span><span class="n">model_name</span><span class="p">]</span>
        <span class="n">peak_name</span> <span class="o">=</span> <span class="n">peak_mod</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">bkg_name</span> <span class="o">=</span> <span class="n">bkg_mod</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;import numpy as np</span><span class="se">\n</span><span class="s2">from lmfit import models</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">data</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">peak_centers = </span><span class="si">%s</span><span class="se">\n\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">peak_centers</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;mod = models.</span><span class="si">%s</span><span class="s2">(prefix=&#39;bkg_&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">bkg_name</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;for n in range(len(peak_centers)):</span><span class="se">\n</span><span class="s2">    mod += models.</span><span class="si">%s</span><span class="s2">(prefix=&#39;p</span><span class="si">%%</span><span class="s2">d_&#39; </span><span class="si">%%</span><span class="s2"> (n+1))</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">peak_name</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;pars = mod.make_params()</span><span class="se">\n\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;# initial parameters</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;min_wid = np.mean(np.diff(xdata))</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;max_wid = xdata.max() - xdata.min()</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;area = (ydata.max() - ydata.min()) * (3 * min_wid)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;for n in range(1, len(peak_centers)+1):</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    pars[&#39;p</span><span class="si">%d</span><span class="s2">_amplitude&#39; % n].set(value=area/len(peak_centers), min=0)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    pars[&#39;p</span><span class="si">%d</span><span class="s2">_sigma&#39; % n].set(value=3*min_wid, min=min_wid, max=max_wid)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;# find_peak centers</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;for ipar, ival in peak_centers.items():</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    if ipar in pars:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;        pars[ipar].set(value=ival, vary=True)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;# user input parameters</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;for ipar, ival in initial.items():</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    if ipar in pars:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;        pars[ipar].set(value=ival, vary=True)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;for ipar, ival in fixed.items():</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    if ipar in pars:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;        pars[ipar].set(value=ival, vary=False)</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;# Fit data</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;res = mod.fit(ydata, pars, x=xdata, weights=weights, method=&#39;leastsqr&#39;)</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;print(res.fit_report())</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;fig, grid = res.plot()</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;ax1, ax2 = fig.axes</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;comps = res.eval_components()</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;for component in comps.keys():</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    ax2.plot(xdata, comps[component], label=component)</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;    ax2.legend()</span><span class="se">\n\n</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">multipeakfit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">npeaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span>
                 <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit x,y data to a model with multiple peaks using lmfit</span>
<span class="sd">    See: https://lmfit.github.io/lmfit-py/builtin_models.html#example-3-fitting-multiple-peaks-and-using-prefixes</span>
<span class="sd">    E.G.:</span>
<span class="sd">      res = multipeakfit(x, y, npeaks=None, model=&#39;Gauss&#39;, plot_result=True)</span>
<span class="sd">      val = res.params[&#39;p1_amplitude&#39;].value</span>
<span class="sd">      err = res.params[&#39;p1_amplitude&#39;].stderr</span>

<span class="sd">    Peak Search:</span>
<span class="sd">     The number of peaks and initial peak centers will be estimated using the find_peaks function. If npeaks is given,</span>
<span class="sd">     the largest npeaks will be used initially. &#39;min_peak_power&#39; and &#39;peak_distance_idx&#39; can be input to tailor the</span>
<span class="sd">     peak search results.</span>
<span class="sd">     If the peak search returns &lt; npeaks, fitting parameters will initially choose npeaks equally distributed points</span>

<span class="sd">    Peak Models:</span>
<span class="sd">     Choice of peak model: &#39;Gaussian&#39;, &#39;Lorentzian&#39;, &#39;Voight&#39;,&#39; PseudoVoight&#39;</span>
<span class="sd">    Background Models:</span>
<span class="sd">     Choice of background model: &#39;slope&#39;, &#39;exponential&#39;</span>

<span class="sd">    Peak Parameters (%d=number of peak):</span>
<span class="sd">    Parameters in &#39;.._parameters&#39; dicts and in output results. Each peak (upto npeaks) has a set number of parameters:</span>
<span class="sd">     &#39;p%d_amplitude&#39;, &#39;p%d_center&#39;, &#39;p%d_dsigma&#39;, pvoight only: &#39;p%d_fraction&#39;</span>
<span class="sd">     output only: &#39;p%d_fwhm&#39;, &#39;p%d_height&#39;</span>
<span class="sd">    Background parameters:</span>
<span class="sd">     &#39;bkg_slope&#39;, &#39;bkg_intercept&#39;, or for exponential: &#39;bkg_amplitude&#39;, &#39;bkg_decay&#39;</span>

<span class="sd">    Provide initial guess:</span>
<span class="sd">      res = multipeakfit(x, y, model=&#39;Voight&#39;, initial_parameters={&#39;p1_center&#39;:1.23})</span>

<span class="sd">    Fix parameter:</span>
<span class="sd">      res = multipeakfit(x, y, model=&#39;gauss&#39;, fix_parameters={&#39;p1_sigma&#39;: fwhm/2.3548200})</span>

<span class="sd">    :param xvals: array(n) position data</span>
<span class="sd">    :param yvals: array(n) intensity data</span>
<span class="sd">    :param yerrors: None or array(n) - error data to pass to fitting function as weights: 1/errors^2</span>
<span class="sd">    :param npeaks: None or int number of peaks to fit. None will guess the number of peaks</span>
<span class="sd">    :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">    :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">    :param model: str or lmfit.Model, specify the peak model &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">    :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">    :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">    :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">    :param method: str method name, from lmfit fitting methods</span>
<span class="sd">    :param print_result: if True, prints the fit results using fit.fit_report()</span>
<span class="sd">    :param plot_result: if True, plots the results using fit.plot()</span>
<span class="sd">    :return: lmfit.model.ModelResult &lt; fit results object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">gen_weights</span><span class="p">(</span><span class="n">yerrors</span><span class="p">)</span>

    <span class="n">mod</span><span class="p">,</span> <span class="n">pars</span> <span class="o">=</span> <span class="n">generate_model</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">yerrors</span><span class="p">,</span>
                               <span class="n">npeaks</span><span class="o">=</span><span class="n">npeaks</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="n">min_peak_power</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="n">peak_distance_idx</span><span class="p">,</span>
                               <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="n">background</span><span class="p">,</span>
                               <span class="n">initial_parameters</span><span class="o">=</span><span class="n">initial_parameters</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="n">fix_parameters</span><span class="p">)</span>

    <span class="c1"># Fit data against model using choosen method</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">yvals</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">xvals</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">print_result</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span>
        <span class="c1"># Add peak components</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">eval_components</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">xvals</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">comps</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">comps</span><span class="p">[</span><span class="n">component</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">component</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="s2">&quot;----------------------------------------------------------------------------------------------------------------------&quot;</span>
<span class="s2">&quot;------------------------------------------------ ScanFitManager ------------------------------------------------------&quot;</span>
<span class="s2">&quot;----------------------------------------------------------------------------------------------------------------------&quot;</span>


<div class="viewcode-block" id="ScanFitManager"><a class="viewcode-back" href="../../fitting/Code.html#babelscan.fitting.ScanFitManager">[docs]</a><span class="k">class</span> <span class="nc">ScanFitManager</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ScanFitManager</span>
<span class="sd">     Holds several functions for automatically fitting scan data</span>

<span class="sd">    fit = ScanFitManager(scan)</span>
<span class="sd">    fit.peak_ratio(yaxis)  # calculates peak power</span>
<span class="sd">    fit.find_peaks(xaxis, yaxis)  # automated peak finding routine</span>
<span class="sd">    fit.fit(xaxis, yaxis)  # estimate &amp; fit data against a peak profile model using lmfit</span>
<span class="sd">    fit.multi_peak_fit(xaxis, yaxis)  # find peaks &amp; fit multiprofile model using lmfit</span>
<span class="sd">    fit.model_fit(xaxis, yaxis, model, pars)  # fit supplied model against data</span>
<span class="sd">    fit.fit_results()  # return lmfit.ModelResult for last fit</span>
<span class="sd">    fit.fit_values()  # return dict of fit values for last fit</span>
<span class="sd">    fit.fit_report()  # return str of fit report</span>
<span class="sd">    fit.plot()  # plot last lmfit results</span>
<span class="sd">    * xaxis, yaxis are str names of arrays in the scan namespace</span>

<span class="sd">    :param scan: babelscan.Scan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scan</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span> <span class="o">=</span> <span class="n">scan</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls ScanFitManager.fit(...)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_report</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">peak_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ratio signal / error for given dataset</span>
<span class="sd">        From Blessing, J. Appl. Cryst. (1997). 30, 421-426 Equ: (1) + (6)</span>
<span class="sd">          peak_ratio = (sum((y-bkg)/dy^2)/sum(1/dy^2)) / sqrt(i/sum(1/dy^2))</span>
<span class="sd">        :param yaxis: str name or address of array to plot on y axis</span>
<span class="sd">        :return: float ratio signal / err</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">get_plot_data</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">peak_ratio</span><span class="p">(</span><span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find peak shaps in linear-spaced 1d arrays with poisson like numerical values</span>
<span class="sd">        E.G.</span>
<span class="sd">          centres, index, power = self.find_peaks(xaxis, yaxis, min_peak_power=None, peak_distance_idx=10)</span>
<span class="sd">        :param xaxis: str name or address of array to plot on x axis</span>
<span class="sd">        :param yaxis: str name or address of array to plot on y axis</span>
<span class="sd">        :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">        :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">        :return centres: array(m) of peak centers in x, equiv. to xdata[index]</span>
<span class="sd">        :return index: array(m) of indexes in y of peaks that satisfy conditions</span>
<span class="sd">        :return power: array(m) of estimated power of each peak</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">get_plot_data</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">power</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xdata</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">,</span> <span class="n">power</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span>
            <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span> <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit x,y data to a peak model using lmfit</span>
<span class="sd">        E.G.:</span>
<span class="sd">          res = self.fit(&#39;axes&#39;, &#39;signal&#39;, model=&#39;Gauss&#39;)</span>
<span class="sd">          print(res.fit_report())</span>
<span class="sd">          res.plot()</span>
<span class="sd">          val = res.params[&#39;amplitude&#39;].value</span>
<span class="sd">          err = res.params[&#39;amplitude&#39;].stderr</span>

<span class="sd">        Peak Models:</span>
<span class="sd">         Choice of peak model: &#39;Gaussian&#39;, &#39;Lorentzian&#39;, &#39;Voight&#39;,&#39; PseudoVoight&#39;</span>
<span class="sd">        Background Models:</span>
<span class="sd">         Choice of background model: &#39;slope&#39;, &#39;exponential&#39;</span>

<span class="sd">        Peak Parameters (%d=number of peak):</span>
<span class="sd">         &#39;amplitude&#39;, &#39;center&#39;, &#39;sigma&#39;, pvoight only: &#39;fraction&#39;</span>
<span class="sd">         output only: &#39;fwhm&#39;, &#39;height&#39;</span>
<span class="sd">        Background parameters:</span>
<span class="sd">         &#39;bkg_slope&#39;, &#39;bkg_intercept&#39;, or for exponential: &#39;bkg_amplitude&#39;, &#39;bkg_decay&#39;</span>

<span class="sd">        Provide initial guess:</span>
<span class="sd">          res = self.fit(x, y, model=&#39;Voight&#39;, initial_parameters={&#39;p1_center&#39;:1.23})</span>

<span class="sd">        Fix parameter:</span>
<span class="sd">          res = self.fit(x, y, model=&#39;gauss&#39;, fix_parameters={&#39;p1_sigma&#39;: fwhm/2.3548200})</span>

<span class="sd">        :param xaxis: str name or address of array to plot on x axis</span>
<span class="sd">        :param yaxis: str name or address of array to plot on y axis</span>
<span class="sd">        :param model: str, specify the peak model &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">        :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">        :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">        :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">        :param method: str method name, from lmfit fitting methods</span>
<span class="sd">        :param print_result: if True, prints the fit results using fit.fit_report()</span>
<span class="sd">        :param plot_result: if True, plots the results using fit.plot()</span>
<span class="sd">        :return: lmfit.model.ModelResult &lt; fit results object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">get_plot_data</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># lmfit</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">peakfit</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="n">background</span><span class="p">,</span>
                      <span class="n">initial_parameters</span><span class="o">=</span><span class="n">initial_parameters</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="n">fix_parameters</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">peak_results</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">update_namespace</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="s1">&#39;lmfit&#39;</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="s1">&#39;fit_result&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">best_fit</span><span class="p">,</span> <span class="n">other_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fit_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">yname</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">print_result</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">title</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">title</span><span class="p">(),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
            <span class="c1"># plt.subplots_adjust(top=0.85, left=0.15)</span>
            <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xname</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">yname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">multi_peak_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span>
                       <span class="n">npeaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                       <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span>
                       <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span>
                       <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit x,y data to a peak model using lmfit</span>
<span class="sd">        E.G.:</span>
<span class="sd">          res = self.multi_peak_fit(&#39;axes&#39;, &#39;signal&#39;, npeaks=2, model=&#39;Gauss&#39;)</span>
<span class="sd">          print(res.fit_report())</span>
<span class="sd">          res.plot()</span>
<span class="sd">          val1 = res.params[&#39;p1_amplitude&#39;].value</span>
<span class="sd">          val2 = res.params[&#39;p2_amplitude&#39;].value</span>

<span class="sd">        Peak centers:</span>
<span class="sd">         Will attempt a fit using &#39;npeaks&#39; peaks, with centers defined by defalult by the find_peaks function</span>
<span class="sd">          if &#39;npeaks&#39; is None, the number of peaks found by find_peaks will determine npeaks</span>
<span class="sd">          if &#39;npeaks&#39; is greater than the number of peaks found by find_peaks, initial peak centers are evenly</span>
<span class="sd">          distrubuted along xdata.</span>

<span class="sd">        Peak Models:</span>
<span class="sd">         Choice of peak model: &#39;Gaussian&#39;, &#39;Lorentzian&#39;, &#39;Voight&#39;,&#39; PseudoVoight&#39;</span>
<span class="sd">        Background Models:</span>
<span class="sd">         Choice of background model: &#39;slope&#39;, &#39;exponential&#39;</span>

<span class="sd">        Peak Parameters (%d=number of peak):</span>
<span class="sd">         &#39;p%d_amplitude&#39;, &#39;p%d_center&#39;, &#39;p%d_sigma&#39;, pvoight only: &#39;p%d_fraction&#39;</span>
<span class="sd">         output only: &#39;p%d_fwhm&#39;, &#39;p%d_height&#39;</span>
<span class="sd">        Background parameters:</span>
<span class="sd">         &#39;bkg_slope&#39;, &#39;bkg_intercept&#39;, or for exponential: &#39;bkg_amplitude&#39;, &#39;bkg_decay&#39;</span>
<span class="sd">        Total parameters (always available, output only - sum/averages of all peaks):</span>
<span class="sd">         &#39;amplitude&#39;, &#39;center&#39;, &#39;sigma&#39;, &#39;fwhm&#39;, &#39;height&#39;, &#39;background&#39;</span>

<span class="sd">        Provide initial guess:</span>
<span class="sd">          res = self.multi_peak_fit(x, y, model=&#39;Voight&#39;, initial_parameters={&#39;p1_center&#39;:1.23})</span>

<span class="sd">        Fix parameter:</span>
<span class="sd">          res = self.multi_peak_fit(x, y, model=&#39;gauss&#39;, fix_parameters={&#39;p1_sigma&#39;: fwhm/2.3548200})</span>

<span class="sd">        :param xaxis: str name or address of array to plot on x axis</span>
<span class="sd">        :param yaxis: str name or address of array to plot on y axis</span>
<span class="sd">        :param npeaks: None or int number of peaks to fit. None will guess the number of peaks</span>
<span class="sd">        :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">        :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">        :param model: str, specify the peak model &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">        :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">        :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">        :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">        :param method: str method name, from lmfit fitting methods</span>
<span class="sd">        :param print_result: if True, prints the fit results using fit.fit_report()</span>
<span class="sd">        :param plot_result: if True, plots the results using fit.plot()</span>
<span class="sd">        :return: lmfit.model.ModelResult &lt; fit results object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">get_plot_data</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># lmfit</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">multipeakfit</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">npeaks</span><span class="o">=</span><span class="n">npeaks</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="n">min_peak_power</span><span class="p">,</span>
                           <span class="n">peak_distance_idx</span><span class="o">=</span><span class="n">peak_distance_idx</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="n">background</span><span class="p">,</span>
                           <span class="n">initial_parameters</span><span class="o">=</span><span class="n">initial_parameters</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="n">fix_parameters</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">peak_results</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">update_namespace</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="s1">&#39;lmfit&#39;</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="s1">&#39;fit_result&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">best_fit</span><span class="p">,</span> <span class="n">other_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fit_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">yname</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">print_result</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">title</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Totals:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">string</span><span class="p">([</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;fwhm&#39;</span><span class="p">,</span> <span class="s1">&#39;background&#39;</span><span class="p">])))</span>
        <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">title</span><span class="p">(),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
            <span class="c1"># plt.subplots_adjust(top=0.85, left=0.15)</span>
            <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xname</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">yname</span><span class="p">)</span>
            <span class="n">comps</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">eval_components</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">comps</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">comps</span><span class="p">[</span><span class="n">component</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">component</span><span class="p">)</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">modelfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span>
                 <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit data from scan against lmfit model</span>
<span class="sd">        :param xaxis: str name or address of array to plot on x axis</span>
<span class="sd">        :param yaxis: str name or address of array to plot on y axis</span>
<span class="sd">        :param model: lmfit.Model - object defining combination of models</span>
<span class="sd">        :param pars: lmfit.Parameters - object defining model parameters</span>
<span class="sd">        :param method: str name of fitting method to use</span>
<span class="sd">        :param print_result: bool, if True, print results.fit_report()</span>
<span class="sd">        :param plot_result: bool, if True, generate results.plot()</span>
<span class="sd">        :return: lmfit fit results</span>

<span class="sd">        Example:</span>
<span class="sd">            from lmfit.models import GaussianModel, LinearModel</span>
<span class="sd">            mod = GaussainModel(prefix=&#39;p1_&#39;) + LinearModel(prefix=&#39;bkg_&#39;)</span>
<span class="sd">            pars = mod.make_params()</span>
<span class="sd">            pars[&#39;p1_center&#39;].set(value=np.mean(x), min=x.min(), max=x.max())</span>
<span class="sd">            res = scan.fit.modelfit(&#39;axis&#39;, &#39;signal&#39;, mod, pars)</span>
<span class="sd">            print(res.fit_report())</span>
<span class="sd">            res.plot()</span>
<span class="sd">            area = res.params[&#39;p1_amplitude&#39;].value</span>
<span class="sd">            err = res.params[&#39;p1_amplitude&#39;].stderr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">get_plot_data</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># weights</span>
        <span class="k">if</span> <span class="n">yerror</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">yerror</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">):</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">yerror</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

        <span class="c1"># Default model, pars</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">LinearModel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">pars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pars</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">guess</span><span class="p">(</span><span class="n">ydata</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">xdata</span><span class="p">)</span>

        <span class="c1"># lmfit</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">ydata</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">xdata</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="s1">&#39;lmfit&#39;</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="s1">&#39;fit_result&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="s1">&#39;fit&#39;</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">best_fit</span><span class="p">,</span> <span class="n">other_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fit_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">yname</span><span class="p">])</span>
        <span class="n">fit_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ename</span> <span class="o">=</span> <span class="s1">&#39;stderr_&#39;</span> <span class="o">+</span> <span class="n">pname</span>
            <span class="n">fit_dict</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">fit_dict</span><span class="p">[</span><span class="n">ename</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">stderr</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fit_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># Add peak components</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">eval_components</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">xdata</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">comps</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">add2namespace</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">fit&#39;</span> <span class="o">%</span> <span class="n">component</span><span class="p">,</span> <span class="n">comps</span><span class="p">[</span><span class="n">component</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">print_result</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">title</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">plot_result</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
            <span class="c1"># plt.suptitle(self.title(), fontsize=12)</span>
            <span class="c1"># plt.subplots_adjust(top=0.85, left=0.15)</span>
            <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xname</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">yname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">gen_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span>
                       <span class="n">npeaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                       <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span>
                       <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate lmfit model and parameters</span>
<span class="sd">        :param xaxis: str name or address of array to plot on x axis</span>
<span class="sd">        :param yaxis: str name or address of array to plot on y axis</span>
<span class="sd">        :param npeaks: None or int number of peaks to fit. None will guess the number of peaks</span>
<span class="sd">        :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">        :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">        :param model: str, specify the peak model &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">        :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">        :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">        :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">        :return: model, pars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">get_plot_data</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">mod</span><span class="p">,</span> <span class="n">pars</span> <span class="o">=</span> <span class="n">generate_model</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span>
                                   <span class="n">npeaks</span><span class="o">=</span><span class="n">npeaks</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="n">min_peak_power</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="n">peak_distance_idx</span><span class="p">,</span>
                                   <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="n">background</span><span class="p">,</span>
                                   <span class="n">initial_parameters</span><span class="o">=</span><span class="n">initial_parameters</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="n">fix_parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mod</span><span class="p">,</span> <span class="n">pars</span>

    <span class="k">def</span> <span class="nf">gen_model_script</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span>
                         <span class="n">npeaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
                         <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span>
                         <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_babelscan</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate script string of</span>
<span class="sd">        :param xaxis: str name or address of array to plot on x axis</span>
<span class="sd">        :param yaxis: str name or address of array to plot on y axis</span>
<span class="sd">        :param npeaks: None or int number of peaks to fit. None will guess the number of peaks</span>
<span class="sd">        :param min_peak_power: float, only return peaks with power greater than this. If None compare against std(y)</span>
<span class="sd">        :param peak_distance_idx: int, group adjacent maxima if closer in index than this</span>
<span class="sd">        :param model: str, specify the peak model &#39;Gaussian&#39;,&#39;Lorentzian&#39;,&#39;Voight&#39;</span>
<span class="sd">        :param background: str, specify the background model: &#39;slope&#39;, &#39;exponential&#39;</span>
<span class="sd">        :param initial_parameters: None or dict of initial values for parameters</span>
<span class="sd">        :param fix_parameters: None or dict of parameters to fix at positions</span>
<span class="sd">        :param include_babelscan: if False, only include imports for lmfit</span>
<span class="sd">        :return: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span> <span class="n">xname</span><span class="p">,</span> <span class="n">yname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">get_plot_data</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">generate_model_script</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">yerror</span><span class="p">,</span>
                                    <span class="n">npeaks</span><span class="o">=</span><span class="n">npeaks</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="n">min_peak_power</span><span class="p">,</span>
                                    <span class="n">peak_distance_idx</span><span class="o">=</span><span class="n">peak_distance_idx</span><span class="p">,</span>
                                    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="n">background</span><span class="p">,</span>
                                    <span class="n">initial_parameters</span><span class="o">=</span><span class="n">initial_parameters</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="n">fix_parameters</span><span class="p">,</span>
                                    <span class="n">include_babelscan</span><span class="o">=</span><span class="n">include_babelscan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">fit_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns parameter, error from the last run fit</span>
<span class="sd">        :param parameter_name: str, name from last fit e.g. &#39;amplitude&#39;, or None to return lmfit object</span>
<span class="sd">        :param</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">isinnamespace</span><span class="p">(</span><span class="s1">&#39;lmfit&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
        <span class="n">lmfit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="s1">&#39;lmfit&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parameter_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lmfit</span>
        <span class="n">param</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">parameter_name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">stderr</span>

    <span class="k">def</span> <span class="nf">fit_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_result</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return dict of values from last fit&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fit_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lmfit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_result</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">peak_results</span><span class="p">(</span><span class="n">lmfit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit_report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_result</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return lmfit.ModelResult.fit_report()&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fit_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lmfit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_result</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">fit_report</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_result</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot fit results&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fit_result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lmfit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_result</span><span class="p">()</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">grid</span> <span class="o">=</span> <span class="n">lmfit</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">title</span><span class="p">(),</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="c1"># plt.subplots_adjust(top=0.85, left=0.15)</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">axes</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>


<span class="s2">&quot;----------------------------------------------------------------------------------------------------------------------&quot;</span>
<span class="s2">&quot;---------------------------------------------- MultiScanFitManager ---------------------------------------------------&quot;</span>
<span class="s2">&quot;----------------------------------------------------------------------------------------------------------------------&quot;</span>


<div class="viewcode-block" id="MultiScanFitManager"><a class="viewcode-back" href="../../fitting/Code.html#babelscan.fitting.MultiScanFitManager">[docs]</a><span class="k">class</span> <span class="nc">MultiScanFitManager</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MultiScanFitManager</span>
<span class="sd">    Enables fitting across multiple scans in a multiscan object</span>

<span class="sd">    fit = MultiScanFitManager(scans)</span>
<span class="sd">    fit.fit(xaxis, yaxis)  # estimate &amp; fit data against a peak profile model using lmfit</span>
<span class="sd">    fit.multi_peak_fit(xaxis, yaxis)  # find peaks &amp; fit multiprofile model using lmfit</span>
<span class="sd">    fit.model_fit(xaxis, yaxis, model, pars)  # fit supplied model against data</span>
<span class="sd">    fit.fit_results()  # return lmfit.ModelResult for last fit</span>
<span class="sd">    fit.fit_values()  # return dict of fit values for last fit</span>
<span class="sd">    fit.fit_report()  # return str of fit report</span>
<span class="sd">    fit.plot()  # plot last lmfit results</span>
<span class="sd">    * xaxis, yaxis are str names of arrays in the scan namespace</span>

<span class="sd">    :param scan: babelscan.MultiScan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiscan</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiscan</span> <span class="o">=</span> <span class="n">multiscan</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls ScanFitManager.fit(...)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span>
            <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span> <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatic fitting of scan</span>

<span class="sd">        Use LMFit</span>
<span class="sd">        Pass fit_type = LMFit model</span>
<span class="sd">        return LMFit output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">scan</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">background</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span>
                     <span class="n">print_result</span><span class="p">,</span> <span class="n">plot_result</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiscan</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">multi_peak_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span>
                       <span class="n">npeaks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                       <span class="n">model</span><span class="o">=</span><span class="s1">&#39;Gaussian&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="s1">&#39;slope&#39;</span><span class="p">,</span>
                       <span class="n">initial_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fix_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span>
                       <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatic fitting of scan</span>

<span class="sd">        Use LMFit</span>
<span class="sd">        Pass fit_type = LMFit model</span>
<span class="sd">        return LMFit output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">scan</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">multi_peak_fit</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span>
                                    <span class="n">npeaks</span><span class="o">=</span><span class="n">npeaks</span><span class="p">,</span> <span class="n">min_peak_power</span><span class="o">=</span><span class="n">min_peak_power</span><span class="p">,</span> <span class="n">peak_distance_idx</span><span class="o">=</span><span class="n">peak_distance_idx</span><span class="p">,</span>
                                    <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="n">background</span><span class="p">,</span> <span class="n">initial_parameters</span><span class="o">=</span><span class="n">initial_parameters</span><span class="p">,</span>
                                    <span class="n">fix_parameters</span><span class="o">=</span><span class="n">fix_parameters</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                    <span class="n">print_result</span><span class="o">=</span><span class="n">print_result</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="n">plot_result</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiscan</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">model_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xaxis</span><span class="o">=</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="n">yaxis</span><span class="o">=</span><span class="s1">&#39;signal&#39;</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;leastsq&#39;</span><span class="p">,</span>
                  <span class="n">print_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatic fitting of scan against given lmfit Model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">scan</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">model_fit</span><span class="p">(</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">pars</span><span class="o">=</span><span class="n">pars</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                               <span class="n">print_result</span><span class="o">=</span><span class="n">print_result</span><span class="p">,</span> <span class="n">plot_result</span><span class="o">=</span><span class="n">plot_result</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">scan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiscan</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">out</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Dan Porter.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>